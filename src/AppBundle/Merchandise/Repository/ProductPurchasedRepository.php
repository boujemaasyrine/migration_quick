<?php

namespace AppBundle\Merchandise\Repository;

use AppBundle\Merchandise\Entity\LossSheet;
use AppBundle\Merchandise\Entity\ProductPurchased;
use AppBundle\Merchandise\Entity\ProductPurchasedMvmt;
use AppBundle\Merchandise\Entity\Restaurant;
use AppBundle\Merchandise\Entity\Supplier;
use AppBundle\Merchandise\Entity\Transfer;
use AppBundle\ToolBox\Utils\DateUtilities;
use Doctrine\ORM\EntityRepository;
use AppBundle\ToolBox\Utils\Utilities;
use Doctrine\ORM\Query;
use Doctrine\ORM\Query\Expr\Join;
use Gedmo\Translatable\TranslatableListener;

/**
 * ProductSoldRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProductPurchasedRepository extends EntityRepository
{
    /**
     * Filter by category id if not null
     *
     * @param  null $searchArray
     * @param  null $filters
     * @param  null $filters
     *
     * @return array
     */
    public function findProduct(
        $restaurant,
        $searchArray = null,
        $filters = null,
        $onlyActiveToInactiveProduct = false
    ) {
        $qb = $this->_em->createQueryBuilder();
        $qb->select('p')->from('Merchandise:ProductPurchased', 'p')
            ->leftJoin('p.productCategory', 'c');
        $conditions = [];
        if ($onlyActiveToInactiveProduct) {
            $conditions[] = $qb->expr()->neq(
                'p.status',
                "'".ProductPurchased::INACTIVE."'"
            );
        }
        if (!is_null($searchArray)) {
            if (array_key_exists('term', $searchArray)) {
                $term = $searchArray['term'];
                $conditions[] = $qb->expr()->orX()->addMultiple(
                    [
                        $qb->expr()->like(
                            'UPPER(p.name)',
                            "'%".strtoupper($term)."%'"
                        ),
                        $qb->expr()->like(
                            'UPPER(p.externalId)',
                            "'%".strtoupper($term)."%'"
                        ),
                    ]
                );
            }
            if (array_key_exists('code', $searchArray)) {
                $code = $searchArray['code'];
                $conditions[] = $qb->expr()->orX()->addMultiple(
                    [
                        $qb->expr()->like(
                            'UPPER(p.name)',
                            "'%".strtoupper($code)."%'"
                        ),
                        $qb->expr()->like(
                            'UPPER(p.externalId)',
                            "'%".strtoupper($code)."%'"
                        ),
                    ]
                );
            }
        }
        if (!is_null($filters) && array_key_exists('categoryId', $filters)) {
            $categoryId = $filters['categoryId'];
            $conditions[] = $qb->expr()->orX()->addMultiple(
                [
                    $qb->expr()->eq('c.id = :categoryId', $categoryId),
                ]
            );
        }
        $conditions = call_user_func_array([$qb->expr(), 'andx'], $conditions);
        $qb->where($conditions);

        if (!is_null($searchArray)
            && array_key_exists(
                'filterSecondary',
                $filters
            )
            && $filters['filterSecondary'] == true
        ) {
            $qb->andWhere('p.primaryItem is null');
        }

        $qb->andWhere('p.originRestaurant=:restaurant')->setParameter(
            'restaurant',
            $restaurant
        );

        if (!array_key_exists('locale', $filters)) {
            $locale = 'fr';
        } else {
            $locale = $filters['locale'];
        }

        $query = $qb->getQuery();
        $query->setHint(
            Query::HINT_CUSTOM_OUTPUT_WALKER,
            'Gedmo\\Translatable\\Query\\TreeWalker\\TranslationWalker'
        );
        $query->setHint(
            TranslatableListener::HINT_TRANSLATABLE_LOCALE,
            $locale
        );
        $products = $query->getResult();

        $data = [];
        foreach ($products as $product) {
            /**
             * @var ProductPurchased $product
             */
            $data[] = array(
                'id'                 => $product->getId(),
                'externalId'         => $product->getExternalId(),
                'name'               => $product->getName(),
                'inventoryQty'       => $product->getInventoryQty(),
                'usageQty'           => $product->getUsageQty(),
                'labelUnitInventory' => $product->getLabelUnitInventory(),
                'labelUnitUsage'     => $product->getLabelUnitUsage(),
                'labelUnitExped'     => $product->getLabelUnitExped(),

            );
        }

        return $data;
    }

    public function getInventoryItemsOrdered(
        $criteria,
        $order,
        $offset,
        $limit,
        $onlyList = false
    ) {

        $queryBuilder = $this->createQueryBuilder('i');
        $queryBuilder->join('i.suppliers', 's');

        $queryBuilder->andWhere('i.status <> :inactive')
            ->setParameter('inactive', ProductPurchased::INACTIVE);

        // total of elements (no filtering)
        if (!$onlyList) {
            $qb1 = clone $queryBuilder;
            $total = $qb1->select('count(i)')
                ->andWhere('i.originRestaurant = :restaurant')
                ->setParameter('restaurant', $criteria['restaurant'])
                ->getQuery()->getSingleScalarResult();
        }

        //filtering

        if ($criteria !== null && is_array($criteria) && count($criteria) > 0) {
            if (Utilities::exist(
                    $criteria,
                    'inventory_item_search[supplierSearch'
                )
                || Utilities::exist($criteria, 'inventory_item_search[keyword')
            ) {
            }
            if (Utilities::exist(
                $criteria,
                'inventory_item_search[suppliers'
            )
            ) {
                $queryBuilder->andWhere("s.id = :supplier ")
                    ->setParameter(
                        "supplier",
                        $criteria['inventory_item_search[suppliers']
                    );
            }

            if (Utilities::exist($criteria, 'inventory_item_search[name')) {
                $queryBuilder->andWhere("lower(i.name) LIKE :name ")
                    ->setParameter(
                        "name",
                        "%".strtolower($criteria['inventory_item_search[name'])
                        ."%"
                    );
            }

            if (Utilities::exist($criteria, 'inventory_item_search[status')) {
                $queryBuilder->andWhere("i.status = :status ")
                    ->setParameter(
                        "status",
                        $criteria['inventory_item_search[status']
                    );
            }

            if (Utilities::exist($criteria, 'inventory_item_search[keyword')) {
                $queryBuilder->andWhere(
                    "lower(i.name) LIKE :keyword OR lower(i.externalId) LIKE :keyword
                OR lower(s.name) LIKE :keyword"
                )
                    ->setParameter(
                        "keyword",
                        "%".strtolower(
                            $criteria['inventory_item_search[keyword']
                        )."%"
                    );
            }

            if (isset($criteria['restaurant'])) {
                $queryBuilder->andWhere('i.originRestaurant = :restaurant')
                    ->setParameter('restaurant', $criteria['restaurant']);
            }
        }

        if (!$onlyList) {
            $qb2 = clone $queryBuilder;
            $filtredTotal = $qb2->select('count(i)')
                ->getQuery()->getSingleScalarResult();
        }

        //ordering
        if ($order !== null && is_array($order) && count($order) > 0) {
            if (Utilities::exist($order, 'col')) {
                if (Utilities::exist($order, 'dir')) {
                    $orderDir = $order['dir'];
                } else {
                    $orderDir = 'asc';
                }
                switch ($order['col']) {
                    case 'code':
                        $queryBuilder->orderBy('i.externalId', $orderDir);
                        break;
                    case 'name':
                        $queryBuilder->orderBy('i.name', $orderDir);
                        break;
                    case 'buyingCost':
                        $queryBuilder->orderBy('i.buyingCost', $orderDir);
                        break;
                    case 'supplier':
                        $queryBuilder->orderBy('s.name', $orderDir);
                        break;
                    case 'status':
                        $queryBuilder->orderBy('i.status', $orderDir);
                        break;
                }
            }
        }
        if ($limit !== null) {
            $queryBuilder->setMaxResults(intval($limit));
        }

        if ($offset !== null) {
            $queryBuilder->setFirstResult(intval($offset));
        }
        $query = $queryBuilder->getQuery();
        $query->setHint(
            Query::HINT_CUSTOM_OUTPUT_WALKER,
            'Gedmo\\Translatable\\Query\\TreeWalker\\TranslationWalker'
        );
        if (!array_key_exists('locale', $criteria)) {
            $locale = 'fr';
        } else {
            $locale = $criteria['locale'];
        }
        $query->setHint(
            TranslatableListener::HINT_TRANSLATABLE_LOCALE,
            $locale
        );
        if ($onlyList) {
            return $query->getResult();
        } else {
            return array(
                'list'    => $query->getResult(),
                'total'   => $total,
                'filtred' => $filtredTotal,
            );
        }
    }


    public function getSupervisonInventoryItemsOrdered(
        $criteria,
        $order,
        $offset,
        $limit,
        $onlyList = false
    ) {

        $queryBuilder = $this->createQueryBuilder('i');

        if (!$onlyList) {
            $qb1 = clone $queryBuilder;
            $total = $qb1->select('count(i)')
                ->getQuery()->getSingleScalarResult();
        }


        //filtering
        if ($criteria !== null && is_array($criteria) && count($criteria) > 0) {
            if (Utilities::exist(
                    $criteria,
                    'inventory_item_search[supplierSearch'
                )
                or Utilities::exist($criteria, 'inventory_item_search[keyword')
            ) {
                $queryBuilder->leftJoin('i.supplier', 's');
            }
            if (Utilities::exist(
                $criteria,
                'inventory_item_search[supplierSearch'
            )
            ) {
                $queryBuilder->andWhere("s.id = :supplier ")
                    ->setParameter(
                        "supplier",
                        $criteria['inventory_item_search[supplierSearch']
                    );
            }

            if (Utilities::exist(
                $criteria,
                'inventory_item_search[nameSearch'
            )
            ) {
                $queryBuilder->andWhere("lower(i.name) LIKE :name ")
                    ->setParameter(
                        "name",
                        "%".strtolower(
                            $criteria['inventory_item_search[nameSearch']
                        )."%"
                    );
            }

            if (Utilities::exist(
                $criteria,
                'inventory_item_search[statusSearch'
            )
            ) {
                $queryBuilder->andWhere("i.status = :status ")
                    ->setParameter(
                        "status",
                        $criteria['inventory_item_search[statusSearch']
                    );
            }

            if (Utilities::exist(
                $criteria,
                'inventory_item_search[codeSearch'
            )
            ) {
                $queryBuilder->andWhere("lower(i.externalId) LIKE :code ")
                    ->setParameter(
                        "code",
                        "%".strtolower(
                            $criteria['inventory_item_search[codeSearch']
                        )."%"
                    );
            }

            if (Utilities::exist(
                $criteria,
                'inventory_item_search[dateSynchro'
            )
            ) {
                $queryBuilder->andWhere("i.dateSynchro = :dateSynchro ")
                    ->setParameter(
                        "dateSynchro",
                        $criteria['inventory_item_search[dateSynchro']
                    );
            }

            if (Utilities::exist(
                $criteria,
                'inventory_item_search[lastDateSynchro'
            )
            ) {
                $queryBuilder->andWhere(
                    "DATE_STRING(i.lastDateSynchro) like :lastDateSynchro "
                )
                    ->setParameter(
                        "lastDateSynchro",
                        $criteria['inventory_item_search[lastDateSynchro']
                    );
            }

            if (Utilities::exist($criteria, 'inventory_item_search[keyword')) {
                $queryBuilder->andWhere(
                    "lower(i.name) LIKE :keyword OR lower(i.externalId) LIKE :keyword
                OR lower(s.name) LIKE :keyword"
                )
                    ->setParameter(
                        "keyword",
                        "%".strtolower(
                            $criteria['inventory_item_search[keyword']
                        )."%"
                    );
            }
        }

        if (!$onlyList) {
            $qb2 = clone $queryBuilder;
            $filtredTotal = $qb2->select('count(i)')
                ->getQuery()->getSingleScalarResult();
        }

        //ordering
        if ($order !== null && is_array($order) && count($order) > 0) {
            if (Utilities::exist($order, 'col')) {
                if (Utilities::exist($order, 'dir')) {
                    $orderDir = $order['dir'];
                } else {
                    $orderDir = 'asc';
                }
                switch ($order['col']) {
                    case 'code':
                        $queryBuilder->orderBy('i.externalId', $orderDir);
                        break;
                    case 'name':
                        $queryBuilder->orderBy('i.name', $orderDir);
                        break;
                    case 'buyingCost':
                        $queryBuilder->orderBy('i.buyingCost', $orderDir);
                        break;
                    case 'deliveryUnit':
                        $queryBuilder->orderBy('i.labelUnitExped', $orderDir);
                        break;
                    case 'inventoryUnit':
                        $queryBuilder->orderBy(
                            'i.labelUnitInventory',
                            $orderDir
                        );
                        break;
                    case 'usageUnit':
                        $queryBuilder->orderBy('i.labelUnitUsage', $orderDir);
                        break;
                    case 'qtyInventory':
                        $queryBuilder->orderBy('i.inventoryQty', $orderDir);
                        break;
                    case 'dateSynchro':
                        $queryBuilder->orderBy('i.dateSynchro', $orderDir);
                        break;
                    case 'lastDateSynchro':
                        $queryBuilder->orderBy('i.lastDateSynchro', $orderDir);
                        break;
                }
            }
        }
        if ($limit !== null) {
            $queryBuilder->setMaxResults(intval($limit));
        }

        if ($offset !== null) {
            $queryBuilder->setFirstResult(intval($offset));
        }

        if ($onlyList) {
            return $queryBuilder->getQuery()->getResult();
        } else {
            return array(
                'list'    => $queryBuilder->getQuery()->getResult(),
                'total'   => $total,
                'filtred' => $filtredTotal,
            );
        }
    }


    private function getPortionControlMainBody($postfix = '')
    {

        $sql
            = '
 (
        SELECT
        /* Product Id */   P.id as PRODUCT_ID,
        /* Category id */  PG.id as category_id,
        /* Category order*/PG.category_order,
        /* Category name*/ PG.name as category_name,
        /* Code */ 	       PP.external_id as code,
        /* Name	*/	       COALESCE(PT.content,P.name) as description,
        /* Format */	   PP.label_unit_inventory as format,
        /* Initial */	   COALESCE(INITIAL.theorical_initial_stock,0) as initial'
            .$postfix.',
        /* Entree */	   COALESCE(ENTREE.qty,0) as entree'.$postfix.',
        /* Sortie */	   COALESCE(SORTIE.qty,0) as sortie'.$postfix.',
        /* Final */	       COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)) as final'
            .$postfix.',
        /* Valeur Final */ COALESCE(PP.buying_cost * (COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0))/PP.inventory_qty),0)  as valeur_final'
            .$postfix.',
        /* ventes */       COALESCE(VENTES.qty,0) as ventes'.$postfix.',
        /* Item vts */     COALESCE(ITEM_VTES.qty,0) as item_vtes'.$postfix.',
        /* Item inv */     COALESCE(ITEM_INV.qty,0) as item_inv'.$postfix.',
        /* Theo */         COALESCE(VENTES.qty + ITEM_INV.qty + ITEM_VTES.qty,0) as theo'
            .$postfix.',
        /* Reel */         COALESCE(INITIAL.theorical_initial_stock + ENTREE.qty - SORTIE.qty - COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)),0)as reel'
            .$postfix.',
        /* ecart */       /* COALESCE( VENTES.qty+ITEM_INV.qty  +ITEM_VTES.qty -  (INITIAL.theorical_initial_stock+  ENTREE.qty  - SORTIE.qty - FINAL.theorical_final_stock),0) as ecart,*/
                           (COALESCE(VENTES.qty,0) + COALESCE(ITEM_INV.qty,0) + COALESCE(ITEM_VTES.qty,0)) - (COALESCE(INITIAL.theorical_initial_stock,0)+ COALESCE(ENTREE.qty,0) )as ecart'
            .$postfix.',
        /* valorisation */ (COALESCE(VENTES.qty, 0) + COALESCE(ITEM_INV.qty, 0) + COALESCE(ITEM_VTES.qty, 0) -
                            ( COALESCE(INITIAL.theorical_initial_stock, 0) + COALESCE(ENTREE.qty, 0) - COALESCE(SORTIE.qty, 0) - COALESCE(COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)), 0)))
                             * ( COALESCE(PP.buying_cost, 0) / COALESCE(PP.inventory_qty, 0) ) as valorisation'
            .$postfix.',

        /* Valeur Initial */ COALESCE(PP.buying_cost * (INITIAL.theorical_initial_stock/PP.inventory_qty),0) as valeur_initial'
            .$postfix.',
	    /* Valeur Entree */ COALESCE(PP.buying_cost * (ENTREE.qty/PP.inventory_qty),0) as valeur_entree'
            .$postfix.',
	    /* Valeur Sortie */ COALESCE(PP.buying_cost * (SORTIE.qty/PP.inventory_qty),0) as valeur_sortie'
            .$postfix.',

	    /*Financial revenue */ COALESCE(VENTES.vente_variation_value,0) as ventes_valorization'
            .$postfix.',
	   /*Inventory loss valorization */ COALESCE(ITEM_VTES.p_vte_variation_value,0) as sold_loss_valorization'
            .$postfix.',
	    /*Solding loss valorization */ COALESCE(ITEM_INV.p_inv_variation_value,0) as inv_loss_valorisation'
            .$postfix.',
	    /*Initial valorization*/ COALESCE(INITIAL.initial_variation_value,0) as initial_valorization'
            .$postfix.',
	    /*Final valorization*/ COALESCE(FINAL.final_value,0) as final_valorization'
            .$postfix.',
	    /* In valorization*/ COALESCE(ENTREE.in_variation_value,0) as in_valorization'
            .$postfix.',
	    /*Out Valorization*/ COALESCE(SORTIE.out_variation_value,0) as out_valorization'
            .$postfix.',


       PP.usage_qty as usage_qty'.$postfix.',
        PP.inventory_qty as inventory_qty'.$postfix.',
        PP.buying_cost as buying_cost'.$postfix.',


        INITIAL.last_inventory_date as initial_inventory_date,
        FINAL.last_final_inventory_date as final_inventory_date,
        PP.status as product_status

        FROM public.product_purchased PP
         /* new */
        /*join product_purchased_mvmt PPM on PPM.product_id = PP.id*/
        /* Category name */
        LEFT JOIN public.product P ON P.id = PP.id
		LEFT JOIN public.product_translations PT on P.id=PT.object_id
        LEFT JOIN public.product_categories PG ON PG.id = PP.product_category_id

        /* INITIAL */
        LEFT JOIN (
            /* STock at D1 */
            SELECT	INITIAL_THEORICAL_STOCK.product_id,
                INITIAL_THEORICAL_STOCK.last_inventory_date,

                CASE WHEN (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation)< 0 THEN 0 ELSE (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation) * INITIAL_THEORICAL_STOCK.inventory_buying_cost end  initial_variation_value,
                CASE WHEN (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation)< 0 THEN 0 ELSE (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation) END theorical_initial_stock
                FROM (
                SELECT MAX(INITIAL_INVENTORY.product_id) as product_id,
                /*MAX(INITIAL_INVENTORY.inventory_buying_cost) as inventory_buying_cost,*/
                INITIAL_INVENTORY.inventory_buying_cost as inventory_buying_cost,
                 MAX(INITIAL_INVENTORY.date_time) as last_inventory_date,
                 case when  MAX(INITIAL_INVENTORY.stock_qty) < 0 then 0 else MAX(INITIAL_INVENTORY.stock_qty) end as initial_stock,
                  COALESCE(SUM(MVMTS.variation),0) as variation, COALESCE(SUM(MVMTS.buying_value),0) as buying_value


                FROM (
                SELECT DISTINCT ON (product_id)
                id, product_id, date_time, stock_qty , (buying_cost / inventory_qty) as inventory_buying_cost
                FROM   product_purchased_mvmt
                where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type = \'inventory\' and date_time < :D1'
            .$postfix.' and stock_qty is not null
                ORDER  BY product_id, date_time DESC, id DESC) INITIAL_INVENTORY
                LEFT JOIN (
                    SELECT product_purchased_mvmt.product_id, product_purchased_mvmt.date_time , product_purchased_mvmt.variation, (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty) as buying_value
                    FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type != \'inventory\' and date_time < :D1'
            .$postfix.'
                ) as MVMTS on INITIAL_INVENTORY.product_id = MVMTS.product_id and DATE(MVMTS.date_time) > DATE(INITIAL_INVENTORY.date_time)
                GROUP BY INITIAL_INVENTORY.product_id, INITIAL_INVENTORY.inventory_buying_cost
            ) as INITIAL_THEORICAL_STOCK
        ) INITIAL on INITIAL.product_id = P.id

        /* ENTREES */
        LEFT JOIN (
            SELECT product_purchased_mvmt.product_id,
                   SUM(product_purchased_mvmt.variation) qty,
                   SUM(product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as in_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'transfer_in\', \'delivery\') and date_time >= :D1'
            .$postfix.' and date_time <= :D2'.$postfix.'
            GROUP BY product_id
        ) ENTREE ON ENTREE.product_id = P.id
        LEFT JOIN (
            /* Sorties */
            SELECT  product_purchased_mvmt.product_id,
                SUM(ABS(product_purchased_mvmt.variation)) qty,
                SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as out_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'transfer_out\', \'returns\') and date_time >= :D1'
            .$postfix.' and date_time <= :D2'.$postfix.'
            GROUP BY product_id
        ) SORTIE ON SORTIE.product_id = P.id
        /* FINAL */
        LEFT JOIN (
            /* Stock at D2 */
            SELECT FINAL_THEORICAL_STOCK.product_id, FINAL_THEORICAL_STOCK.last_final_inventory_date,
                CASE WHEN (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) < 0 THEN 0 ELSE (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) END theorical_final_stock,
                 CASE WHEN (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) < 0 THEN 0 ELSE ((FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) * FINAL_THEORICAL_STOCK.inventory_buying_cost) end final_value
                FROM (
                    SELECT MAX(FINAL_INVENTORY.product_id) as product_id,
                    MAX(FINAL_INVENTORY.id) as op_id,
                    MAX(FINAL_INVENTORY.date_time) as last_final_inventory_date,
                   CASE WHEN MAX(FINAL_INVENTORY.stock_qty) < 0 THEN 0 ELSE MAX(FINAL_INVENTORY.stock_qty) END as final_stock,
                    COALESCE(SUM(MVMTS.variation),0) as variation,
                    FINAL_INVENTORY.inventory_buying_cost as inventory_buying_cost
                    FROM (
                        SELECT DISTINCT ON (product_id)
                        id, product_id, date_time, stock_qty, (buying_cost / inventory_qty) inventory_buying_cost
                        FROM   product_purchased_mvmt
                        where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type = \'inventory\' and date_time <= :D2'
            .$postfix.' and stock_qty is not null
                        ORDER  BY product_id, date_time DESC, id DESC
                    ) FINAL_INVENTORY
                    LEFT JOIN (
                        SELECT product_purchased_mvmt.product_id, product_purchased_mvmt.date_time , product_purchased_mvmt.variation, product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost * product_purchased_mvmt.inventory_qty) as variation_value
                        FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type != \'inventory\' and date_time <= :D2'
            .$postfix.'
                    ) as MVMTS on FINAL_INVENTORY.product_id = MVMTS.product_id and DATE(MVMTS.date_time) > DATE(FINAL_INVENTORY.date_time)
                    GROUP BY FINAL_INVENTORY.product_id, FINAL_INVENTORY.inventory_buying_cost
            ) as FINAL_THEORICAL_STOCK
        ) as FINAL ON FINAL.product_id = P.id

        LEFT JOIN (
            /* Ventes */
            SELECT  product_purchased_mvmt.product_id,
            ABS(SUM(product_purchased_mvmt.variation)) qty, ABS(SUM(product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty))) as vente_variation_value            
			FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'sold\') and date_time >= :D1'
            .$postfix.' and date_time <= :D2'.$postfix.'
            GROUP BY product_id
        ) VENTES ON VENTES.product_id = P.id

        LEFT JOIN (
            /* Pertes Vtes */
            SELECT product_purchased_mvmt.product_id, SUM(ABS(product_purchased_mvmt.variation)) qty, SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as p_vte_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'sold_loss\') and date_time >= :D1'
            .$postfix.' and date_time <= :D2'.$postfix.'
            GROUP BY product_id
        ) ITEM_VTES ON ITEM_VTES.product_id = P.id
        LEFT JOIN (
            /* Pertes Inv */
            SELECT product_purchased_mvmt.product_id,SUM(ABS(product_purchased_mvmt.variation))  qty, SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty))  as p_inv_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'purchased_loss\') and date_time >= :D1'
            .$postfix.' and date_time <= :D2'.$postfix.'
            GROUP BY product_id
        ) ITEM_INV ON ITEM_INV.product_id = P.id
          WHERE P.origin_restaurant_id = :origin_restaurant_id and PT.locale= :locale
        ) PORTION_CONTROL'.$postfix
            .' on PORTION_CONTROL.product_id = PORTION_CONTROL'.$postfix.'.product_id
        ';

        return $sql;
    }


    public function calculatePortionControlData(
        $filter,
        $locale,
        $flag,
        $onlyTotal = false
    ) {

        $this->_em->getConnection()->getConfiguration()->setSQLLogger(null);
        $conn = $this->_em->getConnection();

        $D1 = $filter['startDate'];

        $D2 = $filter['endDate'];

        $startDate = $D1->format('Y/m/d').' 00:00:00';

        $endDate = $D2->format('Y/m/d').' 23:59:59';

        $selection = $filter['selection'];

        /**
         * @var $code string
         */
        $code = isset($filter['code']) ? $filter['code'] : '';
        /**
         * @var $name string
         */
        $name = isset($filter['name']) ? $filter['name'] : '';
        $categories = isset($filter['category']) ? $filter['category'] : [];

        // check if start date and end Date form a week in this case create Dates for the 3 previous weeks

        $isCalendarWeek = DateUtilities::isCalendarWeek($D1, $D2);

        $category_ids = [];
        foreach ($categories as $category) {
            $category_ids[] = $category->getId();
        }

        // $initialQuery = $this->getRealStockProductAtDate(':D1');
        //$finalQuery = $this->getRealStockProductAtDate(':D2');

        $sql
            = '
        SELECT * FROM (
        SELECT
        /* Product Id */   P.id as PRODUCT_ID,
        /* Category id */  PG.id as category_id,
        /* Category order*/PG.category_order,
        /* Category name*/ PG.name as category_name,
        /* Code */ 	       PP.external_id as code,
        /* Name	*/	       COALESCE(PT.content,P.name) as description,
        /* Format */	   PP.label_unit_inventory as format,
        /* Initial */	   COALESCE(INITIAL.theorical_initial_stock,0) as initial,
        /* Entree */	   COALESCE(ENTREE.qty,0) as entree,
        /* Sortie */	   COALESCE(SORTIE.qty,0) as sortie,
        /* Final */	       COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)) as final,
        /* Valeur Final */ COALESCE(PP.buying_cost * (COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0))/PP.inventory_qty),0)  as valeur_final,
        /* ventes */       COALESCE(VENTES.qty,0) as ventes,
        /* Item vts */     COALESCE(ITEM_VTES.qty,0) as item_vtes,
        /* Item inv */     COALESCE(ITEM_INV.qty,0) as item_inv,
        /* Theo */         COALESCE(VENTES.qty + ITEM_INV.qty + ITEM_VTES.qty,0) as theo,
        /* Reel */         COALESCE(INITIAL.theorical_initial_stock + ENTREE.qty - SORTIE.qty - COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)),0)as reel,
        /* ecart */       /* COALESCE( VENTES.qty+ITEM_INV.qty  +ITEM_VTES.qty -  (INITIAL.theorical_initial_stock+  ENTREE.qty  - SORTIE.qty - FINAL.theorical_final_stock),0) as ecart,*/
                           (COALESCE(VENTES.qty,0) + COALESCE(ITEM_INV.qty,0) + COALESCE(ITEM_VTES.qty,0)) - (COALESCE(INITIAL.theorical_initial_stock,0)+ COALESCE(ENTREE.qty,0) )as ecart,
        /* valorisation */ (COALESCE(VENTES.qty, 0) + COALESCE(ITEM_INV.qty, 0) + COALESCE(ITEM_VTES.qty, 0) -
                            ( COALESCE(INITIAL.theorical_initial_stock, 0) + COALESCE(ENTREE.qty, 0) - COALESCE(SORTIE.qty, 0) - COALESCE(COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)), 0)))
                             * ( COALESCE(PP.buying_cost, 0) / COALESCE(PP.inventory_qty, 0) ) as valorisation,

        /* Valeur Initial */ COALESCE(PP.buying_cost * (INITIAL.theorical_initial_stock/PP.inventory_qty),0) as valeur_initial,
	    /* Valeur Entree */ COALESCE(PP.buying_cost * (ENTREE.qty/PP.inventory_qty),0) as valeur_entree,
	    /* Valeur Sortie */ COALESCE(PP.buying_cost * (SORTIE.qty/PP.inventory_qty),0) as valeur_sortie,

	    /*Financial revenue */ COALESCE(VENTES.vente_variation_value,0) as ventes_valorization,
	    /*Inventory loss valorization */ COALESCE(ITEM_VTES.p_vte_variation_value,0) as sold_loss_valorization,
	    /*Solding loss valorization */ COALESCE(ITEM_INV.p_inv_variation_value,0) as inv_loss_valorisation,
	    /*Initial valorization*/ COALESCE(INITIAL.initial_variation_value,0) as initial_valorization,
	    /*Final valorization*/ COALESCE(FINAL.final_value,COALESCE(COALESCE(INITIAL.initial_variation_value,0) + COALESCE(ENTREE.in_variation_value,0) - COALESCE(SORTIE.out_variation_value,0),0 )) as final_valorization,
	    /* In valorization*/ COALESCE(ENTREE.in_variation_value,0) as in_valorization,
	    /*Out Valorization*/ COALESCE(SORTIE.out_variation_value,0) as out_valorization,


        PP.usage_qty,
        PP.inventory_qty,
        PP.buying_cost,

 /*       INITIAL.inventory_line_id as INITIAL_inventory_line_id, */

        INITIAL.last_inventory_date as initial_inventory_date,
 /*       FINAL.inventory_line_id as final_inventory_line_id, */
        FINAL.last_final_inventory_date as final_inventory_date,
        PP.status as product_status,
        PP.deactivation_date as date_desactivation
        FROM public.product_purchased PP
        /* Category name */
        LEFT JOIN public.product P ON P.id = PP.id 
        LEFT JOIN public.product_translations PT on P.id=PT.object_id
        LEFT JOIN public.product_categories PG ON PG.id = PP.product_category_id

        /* INITIAL */
        LEFT JOIN (   
            /* STock at D1 */
            SELECT	INITIAL_THEORICAL_STOCK.product_id,
                INITIAL_THEORICAL_STOCK.last_inventory_date,

                CASE WHEN (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation)< 0 THEN 0 ELSE (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation) * INITIAL_THEORICAL_STOCK.inventory_buying_cost end  initial_variation_value,
                CASE WHEN (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation)< 0 THEN 0 ELSE (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation) END theorical_initial_stock
                FROM (
                SELECT MAX(INITIAL_INVENTORY.product_id) as product_id,
                /*MAX(INITIAL_INVENTORY.inventory_buying_cost) as inventory_buying_cost,*/
                INITIAL_INVENTORY.inventory_buying_cost as inventory_buying_cost,
                 MAX(INITIAL_INVENTORY.date_time) as last_inventory_date,
                 case when  MAX(INITIAL_INVENTORY.stock_qty) < 0 then 0 else MAX(INITIAL_INVENTORY.stock_qty) end as initial_stock,
                  COALESCE(SUM(MVMTS.variation),0) as variation, COALESCE(SUM(MVMTS.buying_value),0) as buying_value


                FROM (
                SELECT DISTINCT ON (product_id)
                id, product_id, date_time, stock_qty , (buying_cost / inventory_qty) as inventory_buying_cost
                FROM   product_purchased_mvmt
                where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type = \'inventory\' and date_time < :D1 and stock_qty is not null
                ORDER  BY product_id, date_time DESC, id DESC) INITIAL_INVENTORY
                LEFT JOIN (
                    SELECT product_purchased_mvmt.product_id, product_purchased_mvmt.date_time , product_purchased_mvmt.variation, (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty) as buying_value
                    FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type != \'inventory\' and date_time < :D1
                ) as MVMTS on INITIAL_INVENTORY.product_id = MVMTS.product_id and DATE(MVMTS.date_time) > DATE(INITIAL_INVENTORY.date_time)
                GROUP BY INITIAL_INVENTORY.product_id, INITIAL_INVENTORY.inventory_buying_cost
            ) as INITIAL_THEORICAL_STOCK
        ) INITIAL on INITIAL.product_id = P.id

        /* ENTREES */
        LEFT JOIN (
            SELECT product_purchased_mvmt.product_id,
                   SUM(product_purchased_mvmt.variation) qty,
                   SUM(product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as in_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'transfer_in\', \'delivery\') and date_time >= :D1 and date_time <= :D2
            GROUP BY product_id
        ) ENTREE ON ENTREE.product_id = P.id
        LEFT JOIN (
            /* Sorties */
            SELECT  product_purchased_mvmt.product_id,
                SUM(ABS(product_purchased_mvmt.variation)) qty,
                SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as out_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'transfer_out\', \'returns\') and date_time >= :D1 and date_time <= :D2
            GROUP BY product_id
        ) SORTIE ON SORTIE.product_id = P.id
        /* FINAL */
        LEFT JOIN (
            /* Stock at D2 */
            SELECT FINAL_THEORICAL_STOCK.product_id, FINAL_THEORICAL_STOCK.last_final_inventory_date,
                CASE WHEN (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) < 0 THEN 0 ELSE (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) END theorical_final_stock,
                 CASE WHEN (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) < 0 THEN 0 ELSE ((FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) * FINAL_THEORICAL_STOCK.inventory_buying_cost) end final_value
                FROM (
                    SELECT MAX(FINAL_INVENTORY.product_id) as product_id,
                    MAX(FINAL_INVENTORY.id) as op_id,
                    MAX(FINAL_INVENTORY.date_time) as last_final_inventory_date,
                   CASE WHEN MAX(FINAL_INVENTORY.stock_qty) < 0 THEN 0 ELSE MAX(FINAL_INVENTORY.stock_qty) END as final_stock,
                    COALESCE(SUM(MVMTS.variation),0) as variation,
                    /*MAX(FINAL_INVENTORY.inventory_buying_cost) as inventory_buying_cost*/
                   FINAL_INVENTORY.inventory_buying_cost as inventory_buying_cost
                    FROM (
                        SELECT DISTINCT ON (product_id)
                        id, product_id, date_time, stock_qty, (buying_cost / inventory_qty) inventory_buying_cost
                        FROM   product_purchased_mvmt
                        where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type = \'inventory\' and date_time <= :D2 and stock_qty is not null
                        ORDER  BY product_id, date_time DESC, id DESC
                    ) FINAL_INVENTORY
                    LEFT JOIN (
                        SELECT product_purchased_mvmt.product_id, product_purchased_mvmt.date_time , product_purchased_mvmt.variation, product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost * product_purchased_mvmt.inventory_qty) as variation_value
                        FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type != \'inventory\' and date_time <= :D2
                    ) as MVMTS on FINAL_INVENTORY.product_id = MVMTS.product_id and DATE(MVMTS.date_time) > DATE(FINAL_INVENTORY.date_time)
                    GROUP BY FINAL_INVENTORY.product_id,  FINAL_INVENTORY.inventory_buying_cost
            ) as FINAL_THEORICAL_STOCK
        ) as FINAL ON FINAL.product_id = P.id

        LEFT JOIN (
            /* Ventes */
            SELECT  product_purchased_mvmt.product_id,
                ABS(SUM(product_purchased_mvmt.variation)) qty, ABS(SUM(product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty))) as vente_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'sold\') and date_time >= :D1 and date_time <= :D2
            GROUP BY product_id
        ) VENTES ON VENTES.product_id = P.id

        LEFT JOIN (
            /* Pertes Vtes */
            SELECT product_purchased_mvmt.product_id, SUM(ABS(product_purchased_mvmt.variation)) qty, SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as p_vte_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'sold_loss\') and date_time >= :D1 and date_time <= :D2
            GROUP BY product_id
        ) ITEM_VTES ON ITEM_VTES.product_id = P.id
        LEFT JOIN (
            /* Pertes Inv */
            SELECT product_purchased_mvmt.product_id,SUM(ABS(product_purchased_mvmt.variation))  qty, SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty))  as p_inv_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in (\'purchased_loss\') and date_time >= :D1 and date_time <= :D2
            GROUP BY product_id
        ) ITEM_INV ON ITEM_INV.product_id = P.id
                WHERE P.origin_restaurant_id = :origin_restaurant_id and PT.locale= :locale
        ) PORTION_CONTROL
        ';
//        if ($isCalendarWeek && $flag == '1') {
//
//            $sql .= ' LEFT JOIN ' . $this->getPortionControlMainBody('_minus_1');
//            $sql .= ' LEFT JOIN ' . $this->getPortionControlMainBody('_minus_2');
//            $sql .= ' LEFT JOIN ' . $this->getPortionControlMainBody('_minus_3');
//        }
                $sql .= ' WHERE (PORTION_CONTROL.product_status = :active OR PORTION_CONTROL.product_status = :toInactive OR  PORTION_CONTROL.date_desactivation >= :D2) ';
        $sql .= ' AND (PORTION_CONTROL.product_id >0) ';

        switch ($selection) {
            case 'inventory_done':
                $sql
                    .= " AND ( (PORTION_CONTROL.initial_inventory_date >= :D1 AND PORTION_CONTROL.initial_inventory_date <= :D2)
                OR (PORTION_CONTROL.final_inventory_date <= :D2 AND PORTION_CONTROL.final_inventory_date >= :D1 )) ";
                break;
        }

        if (!is_null($code)) {
            $sql .= " AND upper(PORTION_CONTROL.code) LIKE :code ";
        }
        if (!is_null($name)) {
            $sql .= " AND upper(PORTION_CONTROL.description) LIKE :name ";
        }
        if (count($categories) > 0) {
            $sql .= " AND ( ";
            $temp = [];
            foreach ($category_ids as $key => $category_id) {
                $temp[] = ' PORTION_CONTROL.category_id = :id'.$key;
            }
            $sql .= implode(' OR ', $temp);
            $sql .= ' ) ';
        }

        // Total Value In, Out, Initial, Final

        if ($onlyTotal) {
            $sql
                = 'SELECT SUM(valeur_initial) AS TotalInitial, SUM(valeur_entree) AS TotalEntree,
	                  SUM(valeur_sortie) AS TotalSortie, SUM(valeur_final) AS TotalFinal, SUM(valorisation) AS portion FROM ('
                .$sql.') TOTAL';
        }

        // Sorting
        if (!$onlyTotal) {
            $sql .= ' ORDER BY PORTION_CONTROL.category_order, PORTION_CONTROL.description ';
        }

        $stm = $conn->prepare($sql);

        // bind
        $stm->bindParam('D1', $startDate);
        $stm->bindParam('D2', $endDate);
        $stm->bindParam('origin_restaurant_id', $filter["currentRestaurantId"]);
        $stm->bindParam('locale', $locale);

//        if($isCalendarWeek && $flag == '1'){
//
//            // -1
//            $D1Minus1 = clone $D1;
//            $D1Minus1->sub( new \DateInterval('P7D'));
//            $D1Minus1 = $D1Minus1->format('Y/m/d');
//
//            $D2Minus1 = clone $D2;
//            $D2Minus1->sub( new \DateInterval('P7D'));
//            $D2Minus1 = $D2Minus1->format('Y/m/d');
//
//            // -2
//            $D1Minus2 = clone $D1;
//            $D1Minus2->sub( new \DateInterval('P14D'));
//            $D1Minus2 = $D1Minus2->format('Y/m/d');
//
//            $D2Minus2 = clone $D2;
//            $D2Minus2->sub( new \DateInterval('P14D'));
//            $D2Minus2 = $D2Minus2->format('Y/m/d');
//
//            // -3
//            $D1Minus3 = clone $D1;
//            $D1Minus3->sub( new \DateInterval('P21D'));
//            $D1Minus3 = $D1Minus3->format('Y/m/d');
//
//            $D2Minus3 = clone $D2;
//            $D2Minus3->sub( new \DateInterval('P21D'));
//            $D2Minus3 = $D2Minus3->format('Y/m/d');
//
//
//            $stm->bindParam('D1_minus_1', $D1Minus1);
//            $stm->bindParam('D2_minus_1', $D2Minus1);
//            $stm->bindParam('D1_minus_2', $D1Minus2);
//            $stm->bindParam('D2_minus_2', $D2Minus2);
//            $stm->bindParam('D1_minus_3', $D1Minus3);
//            $stm->bindParam('D2_minus_3', $D2Minus3);
//
//        }

        if (!is_null($code)) {
            $code = "%".strtoupper($code)."%";
            $stm->bindValue('code', $code);
        }
        if (!is_null($name)) {
            $name = "%".strtoupper($name)."%";
            $stm->bindValue('name', $name);
        }
        if (count($categories) > 0) {
            foreach ($category_ids as $key => $category_id) {
                $stm->bindValue('id'.$key, $category_id, \PDO::PARAM_INT);
            }
        }

        // constant
        $active = ProductPurchased::ACTIVE;
        $toInactive = ProductPurchased::TO_INACTIVE;
                $stm->bindParam('active', $active);
                $stm->bindParam('toInactive', $toInactive);

        $stm->execute();
        //execute
        $data = $stm->fetchAll();
        $result = [
            "data" => $data,
//            "isCalendarWeek" => $isCalendarWeek
        ];

        if ($onlyTotal) {
            return ($result);
        }

        $result = array_merge($result, $filter);

        return $result;
    }

    public function getFiltredProductPurchased($filter, $onlyTotal = false)
    {
        $this->_em->getConnection()->getConfiguration()->setSQLLogger(null);
        $conn = $this->_em->getConnection();

        $D1 = $filter['startDate'];
        $D1 = $D1->format('Y/m/d');

        $D2 = $filter['endDate']->format('Y/m/d');

        $selection = $filter['selection'];

        /**
         * @var $code string
         */
        $code = isset($filter['code']) ? $filter['code'] : '';
        /**
         * @var $name string
         */
        $name = isset($filter['name']) ? $filter['name'] : '';
        $categories = isset($filter['category']) ? $filter['category'] : [];
        $category_ids = [];
        foreach ($categories as $category) {
            $category_ids[] = $category->getId();
        }

        $initialQuery = $this->getRealStockProductAtDate(':D1');
        $finalQuery = $this->getRealStockProductAtDate(':D2');

        $sql
            = '
        SELECT * FROM (
        SELECT
        /* Product Id */   P.id AS PRODUCT_ID,
        /* Category id */  PG.id AS category_id,
        /* Category order*/PG.category_order,
        /* Category name*/ PG.name AS category_name,
        /* Code */ 	       PP.external_id AS code,
        /* Name	*/	       P.name AS description,
        /* Format */	   PP.label_unit_inventory AS format,
        /* Initial */	   COALESCE(INITIAL.theorical_initial_stock,0) < 0 AS initial,
        /* Entree */	   ENTREE.qty AS entree,
        /* Sortie */	   SORTIE.qty AS sortie,
        /* Final */	       FINAL.stock_theorique  AS final,
        /* Valeur Final */ PP.buying_cost * (FINAL.stock_theorique/PP.inventory_qty)  AS valeur_final,
        /* ventes */       VENTES.qty AS ventes,
        /* Item vts */     ITEM_VTES.qty AS item_vtes,
        /* Item inv */     ITEM_INV.qty AS item_inv,
        /* Theo */         VENTES.qty + ITEM_INV.qty + ITEM_VTES.qty AS theo,
        /* Reel */         INITIAL.stock_theorique + ENTREE.qty - SORTIE.qty - FINAL.stock_theorique AS reel,
        /* ecart */        VENTES.qty + ITEM_INV.qty + ITEM_VTES.qty - ( INITIAL.stock_theorique + ENTREE.qty - SORTIE.qty - FINAL.stock_theorique) AS ecart,
        /* valorisation */ (COALESCE(VENTES.qty, 0) + COALESCE(ITEM_INV.qty, 0) + COALESCE(ITEM_VTES.qty, 0) -
                            ( COALESCE(INITIAL.stock_theorique, 0) + COALESCE(ENTREE.qty, 0) - COALESCE(SORTIE.qty, 0) - COALESCE(FINAL.stock_theorique, 0)))
                             * ( COALESCE(PP.buying_cost, 0) / COALESCE(PP.inventory_qty, 0) ) AS valorisation,

        /* Valeur Initial */ PP.buying_cost * (INITIAL.stock_theorique/PP.inventory_qty) AS valeur_initial,
	    /* Valeur Entree */ PP.buying_cost * (ENTREE.qty/PP.inventory_qty) AS valeur_entree,
	    /* Valeur Sortie */ PP.buying_cost * (SORTIE.qty/PP.inventory_qty) AS valeur_sortie,

        PP.usage_qty,
        PP.inventory_qty,
        PP.buying_cost,
        INITIAL.inventory_line_id AS INITIAL_inventory_line_id,
        INITIAL.last_inventory_date AS initial_inventory_date,
        FINAL.inventory_line_id AS final_inventory_line_id,
        FINAL.last_inventory_date AS final_inventory_date,
        PP.status AS product_status

        FROM public.product_purchased PP

        /* Category name */
        LEFT JOIN public.product P ON P.id = PP.id
        LEFT JOIN public.product_categories PG ON PG.id = PP.product_category_id
        /* Inventory lines */
        /* INITIAL */
        LEFT JOIN ('.$initialQuery.') INITIAL ON INITIAL.product = PP.id

        /* FINAL */
        LEFT JOIN ('.$finalQuery.') FINAL ON FINAL.product = PP.id

        /* Entre */
        LEFT JOIN(
            SELECT  _ENTREE.product_id, SUM(_ENTREE.qty) AS qty FROM
                /* Delivery lines */
            (
                        SELECT DL.product_id AS product_id, SUM(DL.qty * product_purchased.inventory_qty ) AS qty FROM public.delivery_line DL
                LEFT JOIN public.product_purchased product_purchased ON product_purchased.id = DL.product_id
                LEFT JOIN public.delivery D ON D.id = DL.delivery_id
                WHERE ( D.date >= :D1 AND D.date <= :D2 )
                GROUP BY DL.product_id

             UNION

                /* Transfer in lines */
            SELECT TL.product_id AS product_id, SUM( (TL.qty_exp * product_purchased.inventory_qty) + TL.qty + (TL.qty_use / product_purchased.usage_qty) ) AS qty FROM public.transfer_line TL
                LEFT JOIN public.product_purchased product_purchased ON product_purchased.id = TL.product_id
                LEFT JOIN public.transfer T ON T.id = TL.transfer_id
                WHERE T.type = :transfer_in AND ( T.date_transfer >= :D1 AND T.date_transfer <= :D2 )
                GROUP BY TL.product_id

            ) _ENTREE GROUP BY _ENTREE.product_id
        ) ENTREE ON ENTREE.product_id = PP.id

        /* Sortie */
        LEFT JOIN (
             SELECT _SORTIE.product_id, SUM(_SORTIE.qty) AS qty FROM
            (

                /* Transfer out lines */
                SELECT TL.product_id AS product_id, SUM( (TL.qty_exp * product_purchased.inventory_qty) + TL.qty + (TL.qty_use / product_purchased.usage_qty) ) AS qty FROM public.transfer_line TL
                LEFT JOIN public.product_purchased product_purchased ON product_purchased.id = TL.product_id
                LEFT JOIN public.transfer T ON T.id = TL.transfer_id
                WHERE T.type = :transfer_out AND ( T.date_transfer >= :D1 AND T.date_transfer <= :D2 )
                GROUP BY TL.product_id

            UNION

                /* returns qtys */
                SELECT RL.product_id AS product_id, SUM( (RL.qty_exp * product_purchased.inventory_qty) + RL.qty + (RL.qty_use / product_purchased.usage_qty) ) AS qty FROM public.return_line RL
                LEFT JOIN public.product_purchased product_purchased ON product_purchased.id = RL.product_id
                LEFT JOIN public.returns R ON R.id = RL.return_id
                WHERE ( R.date >= :D1 AND R.date <= :D2)
                GROUP BY RL.product_id

            ) _SORTIE GROUP BY _SORTIE.product_id
        ) SORTIE ON SORTIE.product_id = PP.id

        /* Ventes */
        LEFT JOIN (
                    SELECT UNION_RESULT.product_id, SUM(UNION_RESULT.qty) AS qty FROM

            (/* transformed products */
                    (SELECT product_purchased.id AS product_id, SUM( (TL.qty * RL.qty) / product_purchased.usage_qty) AS qty
            FROM public.ticket_line TL
            LEFT JOIN public.ticket T ON TL.ticket_id = T.id
            LEFT JOIN public.solding_canal SC ON sc.label = T.destination
            LEFT JOIN public.product_sold product_sold ON product_sold.code_plu = TL.plu
            LEFT JOIN public.recipe recipe ON recipe.product_sold_id = product_sold.id AND recipe.solding_canal_id = SC.id
            LEFT JOIN public.recipe_line RL ON RL.recipe_id = recipe.id
            LEFT JOIN public.product_purchased product_purchased ON product_purchased.id = RL.product_purchased_id
            WHERE  product_sold.product_purchased_id IS NULL AND ( T.enddate >= :D1 AND T.enddate <= :D2)
            GROUP BY product_purchased.id)
        UNION
        /* non transformed products */
        (SELECT product_purchased.id AS product_id, SUM(TL.qty / product_purchased.usage_qty) AS qty
            FROM public.ticket_line TL
            LEFT JOIN public.ticket T ON TL.ticket_id = T.id
            LEFT JOIN public.product_sold product_sold ON product_sold.code_plu = TL.plu
            LEFT JOIN public.product_purchased product_purchased ON product_purchased.id = product_sold.product_purchased_id
            WHERE  product_sold.product_purchased_id IS NOT NULL AND ( T.enddate >= :D1 AND T.enddate <= :D2)
            GROUP BY product_purchased.id)
            ) UNION_RESULT GROUP BY product_id
        ) VENTES ON VENTES.product_id = PP.id

        /* PERTES */
        /* Item vtes */
        LEFT JOIN
                (SELECT RL.product_purchased_id AS product_id, SUM( LL.total_loss * RL.qty / product_purchased.usage_qty ) AS qty
        FROM public.loss_line LL
        LEFT JOIN public.loss_sheet LS ON LL.loss_sheet_id = LS.id
        LEFT JOIN public.recipe recipe ON recipe.id = LL.recipe_id
        LEFT JOIN public.recipe_line RL ON RL.recipe_id = recipe.id
        LEFT JOIN public.product_purchased product_purchased ON RL.product_purchased_id = product_purchased.id
        WHERE LS.type = :finalProduct AND ( LS.entry::DATE >= :D1 AND LS.entry::DATE <= :D2)
        GROUP BY RL.product_purchased_id) ITEM_VTES ON ITEM_VTES.product_id = PP.id

        /* Pertes Item Inv */
        LEFT JOIN
                (SELECT LL.product_id AS product_id, SUM(LL.total_loss) AS qty FROM public.loss_line LL
        LEFT JOIN public.loss_sheet LS ON LL.loss_sheet_id = LS.id
        WHERE LS.type = :article AND ( LS.entry::DATE >= :D1 AND LS.entry::DATE <= :D2)
        GROUP BY LL.product_id
        ) ITEM_INV ON ITEM_INV.product_id = PP.id
        ) PORTION_CONTROL
        WHERE (PORTION_CONTROL.product_status = :active OR PORTION_CONTROL.product_status = :toInactive)
        ';

        switch ($selection) {
            case 'inventory_done':
                $sql .= " AND ( (PORTION_CONTROL.initial_inventory_date >= :D1 AND PORTION_CONTROL.initial_inventory_date <= :D2) OR (PORTION_CONTROL.final_inventory_date <= :D2 AND PORTION_CONTROL.final_inventory_date >= :D1 )) ";
                break;
        }

        if (!is_null($code)) {
            $sql .= " AND upper(PORTION_CONTROL.code) LIKE :code ";
        }
        if (!is_null($name)) {
            $sql .= " AND upper(PORTION_CONTROL.description) LIKE :name ";
        }
        if (count($categories) > 0) {
            $sql .= " AND ( ";
            $temp = [];
            foreach ($category_ids as $key => $category_id) {
                $temp[] = ' PORTION_CONTROL.category_id = :id'.$key;
            }
            $sql .= implode(' OR ', $temp);
            $sql .= ' ) ';
        }

        // Total Value In, Out, Initial, Final

        if ($onlyTotal) {
            $sql
                = 'SELECT SUM(valeur_initial) AS TotalInitial, SUM(valeur_entree) AS TotalEntree,
	                  SUM(valeur_sortie) AS TotalSortie, SUM(valeur_final) AS TotalFinal, SUM(valorisation) AS portion FROM ('
                .$sql.') TOTAL';
        }

        // Sorting
        if (!$onlyTotal) {
            $sql .= ' ORDER BY PORTION_CONTROL.category_order, PORTION_CONTROL.description ';
        }

        $stm = $conn->prepare($sql);
        // bind
        $stm->bindParam('D1', $D1);
        $stm->bindParam('D2', $D2);

        if (!is_null($code)) {
            $code = "%".strtoupper($code)."%";
            $stm->bindValue('code', $code);
        }
        if (!is_null($name)) {
            $name = "%".strtoupper($name)."%";
            $stm->bindValue('name', $name);
        }
        if (count($categories) > 0) {
            foreach ($category_ids as $key => $category_id) {
                $stm->bindValue('id'.$key, $category_id, \PDO::PARAM_INT);
            }
        }

        // constant
        $finalProduct = LossSheet::FINALPRODUCT;
        $article = LossSheet::ARTICLE;
        $active = ProductPurchased::ACTIVE;
        $toInactive = ProductPurchased::TO_INACTIVE;
        $transfer_in = Transfer::TRANSFER_IN;
        $transfer_out = Transfer::TRANSFER_OUT;
        $stm->bindParam('finalProduct', $finalProduct);
        $stm->bindParam('article', $article);
        $stm->bindParam('active', $active);
        $stm->bindParam('toInactive', $toInactive);
        $stm->bindParam('transfer_in', $transfer_in);
        $stm->bindParam('transfer_out', $transfer_out);

        $stm->execute();
        //execute
        $data = $stm->fetchAll();
        $result = [
            "data" => $data,
        ];

        if ($onlyTotal) {
            return ($result);
        }

        $result = array_merge($result, $filter);

        return $result;
    }

    private function getRealStockProductAtDate($targetDateKey)
    {
        $sql
            = "SELECT
  *,
  delivered_qty + transfer_in                                                             AS entree,
  transfer_out + pertes + retours + consomation_non_transformed + consomation_transformed AS sortie,
  CASE WHEN (last_inventory_total + (delivered_qty + transfer_in) -
  (transfer_out + pertes + retours + consomation_non_transformed + consomation_transformed)) <0 THEN 0 ELSE (last_inventory_total + (delivered_qty + transfer_in) -
  (transfer_out + pertes + retours + consomation_non_transformed + consomation_transformed)) END  stock_theorique
FROM
  (
    SELECT
      *,
      COALESCE((
                 SELECT COALESCE(sum(qty * pp.inventory_qty), 0)
                 FROM
                   delivery d JOIN delivery_line dl ON d.id = dl.delivery_id
                   JOIN product_purchased pp ON pp.id = dl.product_id
                 WHERE dl.product_id = product AND
                       d.date :: DATE <= :target_date ::DATE AND
                       d.date :: DATE > last_inventory_date :: DATE
               ), 0) AS \"delivered_qty\",
      COALESCE((
                 SELECT COALESCE(sum(qty), 0) +
                        COALESCE(sum(qty_exp * pp.inventory_qty), 0) +
                        COALESCE(sum(qty_use * pp.usage_qty * pp.inventory_qty), 0)
                 FROM
                   transfer t JOIN transfer_line tl ON t.id = tl.transfer_id
                   JOIN product_purchased pp ON pp.id = tl.product_id
                 WHERE tl.product_id = product AND
                       t.date_transfer :: DATE <= :target_date ::DATE AND
                       t.date_transfer :: DATE > last_inventory_date :: DATE AND
                       t.type = 'transfer_in'
               ), 0) AS \"transfer_in\",
      COALESCE((
                 SELECT COALESCE(sum(qty), 0) +
                        COALESCE(sum(qty_exp * pp.inventory_qty), 0) +
                        COALESCE(sum(qty_use * pp.usage_qty * pp.inventory_qty), 0)
                 FROM
                   transfer t JOIN transfer_line tl ON t.id = tl.transfer_id
                   JOIN product_purchased pp ON pp.id = tl.product_id
                 WHERE tl.product_id = product AND
                       t.date_transfer :: DATE <= :target_date ::DATE AND
                       t.date_transfer :: DATE > last_inventory_date :: DATE AND
                       t.type = 'transfer_out'
               ), 0) AS \"transfer_out\",
      COALESCE((
                 SELECT COALESCE(sum(total_loss), 0)
                 FROM loss_sheet ls JOIN loss_line ll ON ls.id = ll.loss_sheet_id
                 WHERE
                   ll.product_id = product AND
                   ls.entry :: DATE <= :target_date ::DATE AND
                   ls.entry :: DATE > last_inventory_date :: DATE
               ), 0) AS \"pertes\",
      COALESCE((
                 SELECT COALESCE(sum(qty), 0) +
                        COALESCE(sum(qty_exp * pp.inventory_qty), 0) +
                        COALESCE(sum(qty_use * pp.usage_qty * pp.inventory_qty), 0)
                 FROM
                   returns r JOIN return_line rl ON r.id = rl.return_id
                   JOIN product_purchased pp ON pp.id = rl.product_id
                 WHERE rl.product_id = product AND
                       r.date :: DATE <= :target_date ::DATE AND
                       r.date :: DATE > last_inventory_date :: DATE
               ), 0) AS \"retours\",
      COALESCE((
                 SELECT sum(consumed_qty.qty / pp.usage_qty)
                 FROM (
                        SELECT
                          t.date      AS \"date\",
                          tl.plu      AS \"plu\",
                          sum(tl.qty) AS \"qty\"
                        FROM
                          ticket t
                          JOIN ticket_line tl ON t.id = tl.ticket_id
                                                 AND t.status <> -1 AND t.status <> 5 AND t.counted_canceled <> TRUE
                        WHERE qty > 0
                        GROUP BY t.date, tl.plu
                      ) AS consumed_qty
                   LEFT JOIN product_sold ps ON ps.code_plu = consumed_qty.plu
                   LEFT JOIN product_purchased pp ON pp.id = ps.product_purchased_id
                 WHERE
                   ps.product_purchased_id IS NOT NULL AND
                   pp.id = product AND
                   consumed_qty.date :: DATE <= :target_date ::DATE AND
                   consumed_qty.date :: DATE > last_inventory_date :: DATE
                 GROUP BY  pp.id
               ), 0) AS consomation_non_transformed,
      COALESCE((
                 SELECT sum((tl.qty * rl.qty) / pp.usage_qty)
                 FROM
                   ticket t JOIN ticket_line tl ON t.id = tl.ticket_id
                   LEFT JOIN product_sold ps ON ps.code_plu = tl.plu
                   LEFT JOIN recipe r ON ps.id = r.product_sold_id
                   LEFT JOIN solding_canal sc ON sc.id = r.solding_canal_id
                   LEFT JOIN recipe_line rl ON r.id = rl.recipe_id
                   LEFT JOIN product_purchased pp ON pp.id = rl.product_purchased_id
                 WHERE
                   ps.product_purchased_id IS NULL AND
                   pp.id = product AND
                   t.date :: DATE <= :target_date ::DATE AND
                   t.date :: DATE > last_inventory_date :: DATE
                   AND t.status  NOT IN (-1,5) AND t.counted_canceled <> TRUE
                 GROUP BY  pp.id
               ), 0) AS consomation_transformed
    FROM
      (
        SELECT
          :target_date ::DATE AS                   date,
          il.product_id                            product,
          il.total_inventory_cnt                   last_inventory_total,
          iss.fiscal_date :: DATE                  last_inventory_date,
          iss.id                                   inventory_line_id ,
          (:target_date ::DATE = iss.fiscal_date :: DATE) real_stock_exist
        FROM inventory_sheet iss JOIN inventory_line_view il ON iss.id = il.inventory_sheet_id
        WHERE
          iss.fiscal_date :: DATE = (SELECT iss2.fiscal_date :: DATE last_inventory_date
                                     FROM inventory_sheet iss2 JOIN inventory_line_view il2
                                         ON iss2.id = il2.inventory_sheet_id
                                     WHERE
                                       iss2.fiscal_date :: DATE <= :target_date ::DATE AND
                                       il2.product_id = il.product_id
                                     ORDER BY (iss2.fiscal_date, iss2.created_at) DESC
                                     LIMIT 1
          )
      ) AS \"main_sub_query\"
  ) AS \"main_query\"
  ";

        return str_replace(':target_date', $targetDateKey, $sql);
    }

    /**
     * @param $supplier
     *
     * @return ProductPurchased[]
     */
    public function getActiveProducts(Supplier $supplier = null)
    {
        $qb = $this->createQueryBuilder("p")
            ->where("p.status != :inactive")
            ->setParameter("inactive", ProductPurchased::INACTIVE);

        if ($supplier) {
            $qb->andWhere("p.suppliers = :supplier")
                ->setParameter("supplier", $supplier);

            if (count($supplier->getPlannings()) > 0) {
                $cat = [];
                $allCat = false;
                foreach ($supplier->getPlannings() as $p) {
                    if (count($p->getCategories()) == 0) {
                        $allCat = true;
                        break;
                    }
                    foreach ($p->getCategories() as $cc) {
                        $cat[] = $cc->getId();
                    }
                }
                if (!$allCat && $cat != null && is_array($cat)
                    && count($cat) > 0
                ) {
                    $qb->join('p.productCategory', 'c')
                        ->andWhere("c.id in (:cat)")
                        ->setParameter('cat', $cat);
                }
            }
        }

        return $qb->getQuery()->getResult();
    }

    /**
     * @param Supplier $supplier
     *
     * @return ProductPurchased[]
     */
    public function getActiveProductForOrderHelp(
        Supplier $supplier,
        $restaurant = null
    ) {
        $qb = $this->createQueryBuilder("p")
            ->where("p.status != :inactive")
            ->setParameter("inactive", ProductPurchased::INACTIVE);

        if (isset($restaurant)) {
            $qb->andWhere("p.originRestaurant= :restaurant")
                ->setParameter("restaurant", $restaurant);
        }

        if ($supplier) {
            $qb->andWhere(":supplier MEMBER OF p.suppliers")
                ->setParameter("supplier", $supplier);

            if (count($supplier->getPlannings()) > 0) {
                $cat = [];
                $allCat = false;
                foreach ($supplier->getPlannings() as $p) {
                    if (count($p->getCategories()) == 0) {
                        $allCat = true;
                        break;
                    }
                    foreach ($p->getCategories() as $cc) {
                        $cat[] = $cc->getId();
                    }
                }
                if (!$allCat && $cat != null && is_array($cat)
                    && count($cat) > 0
                ) {
                    $qb->join('p.productCategory', 'c')
                        ->andWhere("c.id in (:cat)")
                        ->andWhere('c.eligible = true')
                        ->setParameter('cat', $cat);
                }
            }
        }

        return $qb->getQuery()->getResult();
    }

    /**
     * @param \DateTime $date
     *
     * @return ProductPurchased[]
     */
    public function getActivatedProductsInDay(
        \DateTime $date,
        $getIds = false,
        $restaurant = null
    ) {
        $qb = $this->createQueryBuilder('p')
            ->where('p.status != :intactive')
            ->setParameter('intactive', ProductPurchased::INACTIVE);

        $qb->join('p.productCategory', 'c')
            ->andWhere('c.name != :name')
            ->setParameter('name', '003');

        if (isset($restaurant)) {
            $qb->andWhere('p.originRestaurant = :restaurant')
                ->setParameter('restaurant', $restaurant);
        }

        if ($getIds) {
            $qb->select('p.id');
            $result = $qb->getQuery()->getScalarResult();

            return array_map('current', $result);
        } else {
            return $qb->getQuery()->getResult();
        }
    }


    /*****
     * Supervision Section
     ******/


    public function findProductSupervision($searchArray = null, $filters = null)
    {
        $qb = $this->_em->createQueryBuilder();
        $qb->select(
            'p.id',
            'p.name',
            'p.externalId',
            'p.labelUnitUsage',
            'p.buyingCost',
            'p.inventoryQty',
            'p.usageQty'
        )
            ->from('Merchandise:ProductPurchased', 'p')->leftJoin(
                'p.productCategory',
                'c'
            );
        $conditions = [];

        if (!is_null($searchArray)) {
            if (array_key_exists('term', $searchArray)) {
                $term = $searchArray['term'];
                $conditions[] = $qb->expr()->orX()->addMultiple(
                    [
                        $qb->expr()->like(
                            'UPPER(p.name)',
                            "'%".strtoupper($term)."%'"
                        ),
                        $qb->expr()->like(
                            'UPPER(p.externalId)',
                            "'%".strtoupper($term)."%'"
                        ),
                    ]
                );
            }
            if (array_key_exists('code', $searchArray)) {
                $code = $searchArray['code'];
                $conditions[] = $qb->expr()->orX()->addMultiple(
                    [
                        $qb->expr()->like(
                            'UPPER(p.name)',
                            "'%".strtoupper($code)."%'"
                        ),
                        $qb->expr()->like(
                            'UPPER(p.externalId)',
                            "'%".strtoupper($code)."%'"
                        ),
                    ]
                );
            }
        }
        if (!is_null($filters) && array_key_exists('categoryId', $filters)) {
            $categoryId = $filters['categoryId'];
            $conditions[] = $qb->expr()->orX()->addMultiple(
                [
                    $qb->expr()->eq('c.id = :categoryId', $categoryId),
                ]
            );
        }
        $conditions = call_user_func_array([$qb->expr(), 'andx'], $conditions);
        $qb->where($conditions);

        return $qb->getQuery()->getArrayResult();
    }


    /**
     * @param \DateTime       $date
     * @param Restaurant|null $restaurant
     *
     * @return ProductPurchased[]
     */
    public function getSupervisionActivatedProductsInDay(
        \DateTime $date,
        Restaurant $restaurant = null,
        $getIds = null
    ) {
        $qb = $this->createQueryBuilder('p')
            ->where('p.status != :intactive')
            ->setParameter('intactive', ProductPurchased::INACTIVE);
        if ($restaurant) {
            $qb->andWhere('p.originRestaurant = :restaurant')
                ->setParameter('restaurant', $restaurant);
        }
        if ($getIds) {
            $qb->select('p.id');
            $result = $qb->getQuery()->getScalarResult();

            return array_map('current', $result);
        } else {
            return $qb->getQuery()->getResult();
        }
    }

    /**
     * @param \DateTime $beginDate
     * @param \DateTime $endDate
     * @param null $restaurants
     * @return array
     */
    public function getDataForProductPurchasedReport(\DateTime $beginDate, \DateTime $endDate, $restaurants = null)
    {
        $restaurantIds = implode(',', $this->getIdsFromArrayCollection($restaurants));
        $dataPPMVMTDelivery = $this->getDataForPPMVMTDelivery($beginDate->format('Y/m/d'), $endDate->format('Y/m/d'), $restaurantIds);
        $dataPPMVMTTransfer = $this->getDataForPPMVMTTransfer($beginDate->format('Y/m/d'), $endDate->format('Y/m/d'), $restaurantIds);
        return array($dataPPMVMTDelivery, $dataPPMVMTTransfer);
    }

    /**
     * @param $beginDate
     * @param $endDate
     * @param $restaurantIds
     * @return mixed
     */
    private function getDataForPPMVMTDelivery($beginDate, $endDate, $restaurantIds)
    {
        $conn = $this->_em->getConnection();

        $ppmvmtDelivery = ProductPurchasedMvmt::DELIVERY_TYPE;
        $sql = "SELECT
                    PPMVMT.variation AS ppmvmtVariation,
                    PPMVMT.buying_cost AS ppmvmtBuyingCost,
                    D.date AS dDate,
                    D.deliverybordereau AS dBordereau,
                    PPMVMT.type AS ppmvmtType,
                    R.code AS rCode,
                    P.name AS pName,
                    O.dateorder AS oDateOrder,
                    S.name AS sName,
                    S.code AS sCode,
                    PP.external_id AS ppExternalID
                    From public.product_purchased_mvmt PPMVMT
                    INNER JOIN public.restaurant R ON PPMVMT.origin_restaurant_id = R.id
                    INNER JOIN public.delivery_line DL ON PPMVMT.source_id = DL.id
                    INNER JOIN public.delivery D ON DL.delivery_id = D.id
                    INNER JOIN public.product P ON PPMVMT.product_id = P.id
                    INNER JOIN public.product_purchased PP ON PPMVMT.product_id = PP.id
                    INNER JOIN public.orders O ON D.order_id = O.id
                    INNER JOIN public.supplier S ON O.supplier_id = S.id
                     WHERE R.id IN (" . $restaurantIds . ")and  PPMVMT.date_time>= :beginDate AND PPMVMT.date_time <= :endDate
                     AND PPMVMT.type IN (:ppmvmtType )
                    ";
        // bind

        $stm = $conn->prepare($sql);
        $stm->bindParam('beginDate', $beginDate);
        $stm->bindParam('endDate', $endDate);
        $stm->bindParam("ppmvmtType", $ppmvmtDelivery);
        $stm->execute();

        return $stm->fetchAll();
    }

    /**
     * @param $beginDate
     * @param $endDate
     * @param $restaurantIds
     * @return mixed
     */
    private function getDataForPPMVMTTransfer($beginDate, $endDate, $restaurantIds)
    {
        $conn = $this->_em->getConnection();
        $sql = "SELECT
                    PPMVMT.variation AS ppmvmtVariation,
                    PPMVMT.buying_cost AS ppmvmtBuyingCost,
                    T.date_transfer AS tDate,
                    T.num_transfer AS tNumTransfer,
                    PPMVMT.type AS ppmvmtType,
                    R.code AS rCode,
                    P.name AS pName,
                    PP.external_id AS ppExternalID
                    From public.product_purchased_mvmt PPMVMT
                    INNER JOIN public.restaurant R on PPMVMT.origin_restaurant_id = R.id
                    INNER JOIN public.transfer_line TL ON PPMVMT.source_id = TL.id
                    INNER JOIN public.transfer T ON TL.transfer_id = T.id
                    INNER JOIN public.product P ON PPMVMT.product_id = P.id
                    INNER JOIN public.product_purchased PP ON PPMVMT.product_id = PP.id
                    WHERE R.id IN (" . $restaurantIds . ") AND PPMVMT.date_time >= :beginDate AND PPMVMT.date_time <= :endDate
                     AND PPMVMT.type IN ('" . ProductPurchasedMvmt::TRANSFER_OUT_TYPE . "','" . ProductPurchasedMvmt::TRANSFER_IN_TYPE . "')";
        // bind

        $stm = $conn->prepare($sql);
        $stm->bindParam('beginDate', $beginDate);
        $stm->bindParam('endDate', $endDate);
        $stm->execute();

        return $stm->fetchAll();
    }

    /**
     *
     * @param $ac
     * @return array
     */
    private function getIdsFromArrayCollection($ac)
    {
        $ids = array();
        if (!$ac->isEmpty()) {
            foreach ($ac as $o) {
                $ids[] = (int)$o->getId();
            }
        }
        return $ids;
    }
    
    
      //belsem
    public function getProductsPurchasedByRestaurant( $restaurant)
    {
        return $this->createQueryBuilder('pps')
            ->where(' pps.originRestaurant in (:restaurant)')
            ->andWhere(' pps.active = :t')
            ->setParameter('restaurant', $restaurant)
            ->setParameter('t', true)
            ->getQuery()
            ->getResult();
    }



    /////donee by belsem 2019
    public function getSupervisionRealStockItems($filter,$locale)
    {
        $this->_em->getConnection()->getConfiguration()->setSQLLogger(null);
        $conn = $this->_em->getConnection();
       // $actualDayStock = new \DateTime();

       // $actualDayStock=$actualDayStock->format('d-m-Y');
//get started date
       // $D1 = $filter['startDate'];
//get endDate
       // $D2 = $filter['endDate'];
//format date
        //$startDate = $actualDayStock;
//format date
       // $endDate = $actualDayStock;
        //get restaurants

        $restaurants =  $filter['restaurants'] ;
        $ids=array();
        foreach ( $restaurants as $item) {
            $ids[]=(int)$item->getId();
        }
       $listOfIds = implode(',',array_map('intval', $ids));
        //get products
        $restaurants =  $filter['products'] ;
        $idsProducts=array();
        foreach ( $restaurants as $item) {
            $idsProducts[]="'".$item->getExternalId()."'";
        }
        $listOfIdsProducts = implode(',',$idsProducts);
        $sql = "SELECT * FROM (
        SELECT
        /* Product Id */   P.id as PRODUCT_ID,
        /* Restaurant   */ R.name  as restaurant,
        /* Restaurant code*/ R.code as code_restaurant,
        /* Code */       PP.external_id as code,
        /* Name */       COALESCE(PT.content,P.name) as description, 
        /* Format */       PP.label_unit_inventory as format,
        /* Final */       COALESCE(FINAL.theorical_final_stock,0) as final
        FROM public.product_purchased PP
        LEFT JOIN public.product P ON P.id = PP.id
        LEFT JOIN public.product_translations PT on P.id=PT.object_id
        LEFT JOIN public.restaurant R ON P.origin_restaurant_id = R.id
        /* FINAL */
        LEFT JOIN (
            /* Stock at D2 */
            SELECT FINAL_THEORICAL_STOCK.product_id,
            CASE WHEN (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) < 0 THEN 0 
            ELSE (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) END theorical_final_stock
	FROM (
                    SELECT MAX(FINAL_INVENTORY.product_id) as product_id,
                   CASE WHEN MAX(FINAL_INVENTORY.stock_qty) < 0 THEN 0 ELSE MAX(FINAL_INVENTORY.stock_qty) END as final_stock,
                    COALESCE(SUM(MVMTS.variation),0) as variation
                    /*MAX(FINAL_INVENTORY.inventory_buying_cost) as inventory_buying_cost*/
               
                    FROM (
                        SELECT DISTINCT ON (product_id)
                        id, product_id, date_time, stock_qty
                        FROM   product_purchased_mvmt
                        where product_purchased_mvmt.origin_restaurant_id IN($listOfIds) and deleted = false and type = 'inventory' and date_time <= current_timestamp and stock_qty is not null
                        ORDER  BY product_id, date_time DESC, id DESC
                    ) FINAL_INVENTORY
                    LEFT JOIN (
                        SELECT product_purchased_mvmt.product_id, product_purchased_mvmt.date_time , product_purchased_mvmt.variation
                        FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id IN($listOfIds)
                         and deleted = false and type != 'inventory' and date_time between  current_timestamp - INTERVAL '12' MONTH and current_timestamp
                     ) as MVMTS on FINAL_INVENTORY.product_id = MVMTS.product_id and DATE(MVMTS.date_time) > DATE(FINAL_INVENTORY.date_time)
                    GROUP BY FINAL_INVENTORY.product_id
            ) as FINAL_THEORICAL_STOCK
        ) as FINAL ON FINAL.product_id = P.id
                WHERE P.origin_restaurant_id IN ($listOfIds) and PT.locale=:locale and PP.external_id IN ($listOfIdsProducts) ORDER BY  code
                  ) PORTION_CONTROL
       ";

        $stm = $conn->prepare($sql);
       // $stm->bindParam('D1', $startDate);
        //$stm->bindParam('D2', $endDate);
        //$stm->bindParam('origin_restaurant_id',$listOfIds);
        $stm->bindParam('locale', $locale);
        $stm->execute();
        //execute
        $data = $stm->fetchAll();
        $result = ["data" => $data];
        $result = array_merge($result, $filter);

        return $result;
    }

    public function getDataForWeek($startOfWeek, $endOfWeek,$restaurantId, $locale, $postfix=''){

        $conn = $this->_em->getConnection();
        $sql = "SELECT * FROM (
        SELECT
        /* Product Id */   P.id as PRODUCT_ID,
        /* Category id */  PG.id as category_id,
        /* Category order*/PG.category_order,
        /* Category name*/ PG.name as category_name,
        /* Date de synchro */ P.date_synchro as date_synchro,
        /* Code */ 	       PP.external_id as code,
        /* Name	*/	       COALESCE(PT.content,P.name) as description,
        /* Format */	   PP.label_unit_inventory as format,
        /* Initial */	   COALESCE(INITIAL.theorical_initial_stock,0) as initial".$postfix.",
        /* Entree */	   COALESCE(ENTREE.qty,0) as entree".$postfix.",
        /* Sortie */	   COALESCE(SORTIE.qty,0) as sortie".$postfix.",
        /* Final */	       COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)) as final".$postfix.",
        /* Valeur Final */ COALESCE(PP.buying_cost * (COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0))/PP.inventory_qty),0)  as valeur_final".$postfix.",
        /* ventes */       COALESCE(VENTES.qty,0) as ventes".$postfix.",
        /* Item vts */     COALESCE(ITEM_VTES.qty,0) as item_vtes".$postfix.",
        /* Item inv */     COALESCE(ITEM_INV.qty,0) as item_inv".$postfix.",
        /* Theo */         COALESCE(VENTES.qty + ITEM_INV.qty + ITEM_VTES.qty,0) as theo".$postfix.",
        /* Reel */         COALESCE(INITIAL.theorical_initial_stock + ENTREE.qty - SORTIE.qty - COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)),0)as reel".$postfix.",
        /* ecart */       /* COALESCE( VENTES.qty+ITEM_INV.qty  +ITEM_VTES.qty -  (INITIAL.theorical_initial_stock+  ENTREE.qty  - SORTIE.qty - FINAL.theorical_final_stock),0) as ecart,*/
                           (COALESCE(VENTES.qty,0) + COALESCE(ITEM_INV.qty,0) + COALESCE(ITEM_VTES.qty,0)) - (COALESCE(INITIAL.theorical_initial_stock,0)+ COALESCE(ENTREE.qty,0) )as ecart".$postfix.",
        /* valorisation */ (COALESCE(VENTES.qty, 0) + COALESCE(ITEM_INV.qty, 0) + COALESCE(ITEM_VTES.qty, 0) -
                            ( COALESCE(INITIAL.theorical_initial_stock, 0) + COALESCE(ENTREE.qty, 0) - COALESCE(SORTIE.qty, 0) - COALESCE(COALESCE(FINAL.theorical_final_stock,COALESCE(INITIAL.theorical_initial_stock,0)+COALESCE(ENTREE.qty,0)-COALESCE(SORTIE.qty,0)), 0)))
                             * ( COALESCE(PP.buying_cost, 0) / COALESCE(PP.inventory_qty, 0) ) as valorisation".$postfix.",

        /* Valeur Initial */ COALESCE(PP.buying_cost * (INITIAL.theorical_initial_stock/PP.inventory_qty),0) as valeur_initial".$postfix.",
	    /* Valeur Entree */ COALESCE(PP.buying_cost * (ENTREE.qty/PP.inventory_qty),0) as valeur_entree".$postfix.",
	    /* Valeur Sortie */ COALESCE(PP.buying_cost * (SORTIE.qty/PP.inventory_qty),0) as valeur_sortie".$postfix.",

	    /*Financial revenue */ COALESCE(VENTES.vente_variation_value,0) as ventes_valorization".$postfix.",
	    /*Inventory loss valorization */ COALESCE(ITEM_VTES.p_vte_variation_value,0) as sold_loss_valorization".$postfix.",
	    /*Solding loss valorization */ COALESCE(ITEM_INV.p_inv_variation_value,0) as inv_loss_valorisation".$postfix.",
	    /*Initial valorization*/ COALESCE(INITIAL.initial_variation_value,0) as initial_valorization".$postfix.",
	    /*Final valorization*/ COALESCE(FINAL.final_value,COALESCE(COALESCE(INITIAL.initial_variation_value,0) + COALESCE(ENTREE.in_variation_value,0) - COALESCE(SORTIE.out_variation_value,0),0 )) as final_valorization".$postfix.",
	    /* In valorization*/ COALESCE(ENTREE.in_variation_value,0) as in_valorization".$postfix.",
	    /*Out Valorization*/ COALESCE(SORTIE.out_variation_value,0) as out_valorization".$postfix.",


        PP.usage_qty as usage_qty".$postfix.",
        PP.inventory_qty as inventory_qty".$postfix.",
        PP.buying_cost as buying_cost".$postfix.",

 /*       INITIAL.inventory_line_id as INITIAL_inventory_line_id, */

        INITIAL.last_inventory_date as initial_inventory_date,
 /*       FINAL.inventory_line_id as final_inventory_line_id, */
        FINAL.last_final_inventory_date as final_inventory_date,
        PP.status as product_status,
        PP.deactivation_date as date_desactivation
        FROM public.product_purchased PP
        /* Category name */
        LEFT JOIN public.product P ON P.id = PP.id 
        LEFT JOIN public.product_translations PT on P.id=PT.object_id
        LEFT JOIN public.product_categories PG ON PG.id = PP.product_category_id

        /* INITIAL */
        LEFT JOIN (   
            /* STock at startOfWeek */
            SELECT	INITIAL_THEORICAL_STOCK.product_id,
                INITIAL_THEORICAL_STOCK.last_inventory_date,

                CASE WHEN (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation)< 0 THEN 0 ELSE (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation) * INITIAL_THEORICAL_STOCK.inventory_buying_cost end  initial_variation_value,
                CASE WHEN (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation)< 0 THEN 0 ELSE (INITIAL_THEORICAL_STOCK.initial_stock + INITIAL_THEORICAL_STOCK.variation) END theorical_initial_stock
                FROM (
                SELECT MAX(INITIAL_INVENTORY.product_id) as product_id,
                /*MAX(INITIAL_INVENTORY.inventory_buying_cost) as inventory_buying_cost,*/
                INITIAL_INVENTORY.inventory_buying_cost as inventory_buying_cost,
                 MAX(INITIAL_INVENTORY.date_time) as last_inventory_date,
                 case when  MAX(INITIAL_INVENTORY.stock_qty) < 0 then 0 else MAX(INITIAL_INVENTORY.stock_qty) end as initial_stock,
                  COALESCE(SUM(MVMTS.variation),0) as variation, COALESCE(SUM(MVMTS.buying_value),0) as buying_value


                FROM (
                SELECT DISTINCT ON (product_id)
                id, product_id, date_time, stock_qty , (buying_cost / inventory_qty) as inventory_buying_cost
                FROM   product_purchased_mvmt
                where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type = 'inventory' and date_time < :startOfWeek and stock_qty is not null
                ORDER  BY product_id, date_time DESC, id DESC) INITIAL_INVENTORY
                LEFT JOIN (
                    SELECT product_purchased_mvmt.product_id, product_purchased_mvmt.date_time , product_purchased_mvmt.variation, (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty) as buying_value
                    FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type != 'inventory' and date_time < :startOfWeek
                ) as MVMTS on INITIAL_INVENTORY.product_id = MVMTS.product_id and DATE(MVMTS.date_time) > DATE(INITIAL_INVENTORY.date_time)
                GROUP BY INITIAL_INVENTORY.product_id, INITIAL_INVENTORY.inventory_buying_cost
            ) as INITIAL_THEORICAL_STOCK
        ) INITIAL on INITIAL.product_id = P.id

        /* ENTREES */
        LEFT JOIN (
            SELECT product_purchased_mvmt.product_id,
                   SUM(product_purchased_mvmt.variation) qty,
                   SUM(product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as in_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in ('transfer_in', 'delivery') and date_time >= :startOfWeek and date_time <= :endOfWeek
            GROUP BY product_id
        ) ENTREE ON ENTREE.product_id = P.id
        LEFT JOIN (
            /* Sorties */
            SELECT  product_purchased_mvmt.product_id,
                SUM(ABS(product_purchased_mvmt.variation)) qty,
                SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as out_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in ('transfer_out', 'returns') and date_time >= :startOfWeek and date_time <= :endOfWeek
            GROUP BY product_id
        ) SORTIE ON SORTIE.product_id = P.id
        /* FINAL */
        LEFT JOIN (
            /* Stock at endOfWeek */
            SELECT FINAL_THEORICAL_STOCK.product_id, FINAL_THEORICAL_STOCK.last_final_inventory_date,
                CASE WHEN (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) < 0 THEN 0 ELSE (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) END theorical_final_stock,
                 CASE WHEN (FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) < 0 THEN 0 ELSE ((FINAL_THEORICAL_STOCK.final_stock + FINAL_THEORICAL_STOCK.variation) * FINAL_THEORICAL_STOCK.inventory_buying_cost) end final_value
                FROM (
                    SELECT MAX(FINAL_INVENTORY.product_id) as product_id,
                    MAX(FINAL_INVENTORY.id) as op_id,
                    MAX(FINAL_INVENTORY.date_time) as last_final_inventory_date,
                   CASE WHEN MAX(FINAL_INVENTORY.stock_qty) < 0 THEN 0 ELSE MAX(FINAL_INVENTORY.stock_qty) END as final_stock,
                    COALESCE(SUM(MVMTS.variation),0) as variation,
                    /*MAX(FINAL_INVENTORY.inventory_buying_cost) as inventory_buying_cost*/
                   FINAL_INVENTORY.inventory_buying_cost as inventory_buying_cost
                    FROM (
                        SELECT DISTINCT ON (product_id)
                        id, product_id, date_time, stock_qty, (buying_cost / inventory_qty) inventory_buying_cost
                        FROM   product_purchased_mvmt
                        where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type = 'inventory' and date_time <= :endOfWeek and stock_qty is not null
                        ORDER  BY product_id, date_time DESC, id DESC
                    ) FINAL_INVENTORY
                    LEFT JOIN (
                        SELECT product_purchased_mvmt.product_id, product_purchased_mvmt.date_time , product_purchased_mvmt.variation, product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost * product_purchased_mvmt.inventory_qty) as variation_value
                        FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type != 'inventory' and date_time <= :endOfWeek
                    ) as MVMTS on FINAL_INVENTORY.product_id = MVMTS.product_id and DATE(MVMTS.date_time) > DATE(FINAL_INVENTORY.date_time)
                    GROUP BY FINAL_INVENTORY.product_id,  FINAL_INVENTORY.inventory_buying_cost
            ) as FINAL_THEORICAL_STOCK
        ) as FINAL ON FINAL.product_id = P.id

        LEFT JOIN (
            /* Ventes */
            SELECT  product_purchased_mvmt.product_id,
                ABS(SUM(product_purchased_mvmt.variation)) qty, ABS(SUM(product_purchased_mvmt.variation * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty))) as vente_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in ('sold') and date_time >= :startOfWeek and date_time <= :endOfWeek
            GROUP BY product_id
        ) VENTES ON VENTES.product_id = P.id

        LEFT JOIN (
            /* Pertes Vtes */
            SELECT product_purchased_mvmt.product_id, SUM(ABS(product_purchased_mvmt.variation)) qty, SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty)) as p_vte_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in ('sold_loss') and date_time >= :startOfWeek and date_time <= :endOfWeek
            GROUP BY product_id
        ) ITEM_VTES ON ITEM_VTES.product_id = P.id
        LEFT JOIN (
            /* Pertes Inv */
            SELECT product_purchased_mvmt.product_id,SUM(ABS(product_purchased_mvmt.variation))  qty, SUM(ABS(product_purchased_mvmt.variation) * (product_purchased_mvmt.buying_cost / product_purchased_mvmt.inventory_qty))  as p_inv_variation_value
            FROM product_purchased_mvmt where product_purchased_mvmt.origin_restaurant_id = :origin_restaurant_id and deleted = false and type in ('purchased_loss') and date_time >= :startOfWeek and date_time <= :endOfWeek
            GROUP BY product_id
        ) ITEM_INV ON ITEM_INV.product_id = P.id
                WHERE P.origin_restaurant_id = :origin_restaurant_id and PT.locale= :locale
        ) PORTION_CONTROL WHERE  PORTION_CONTROL.category_id in (1,2,3,5,6,7,9,10,11)";
        $sql .= ' AND  (PORTION_CONTROL.product_status = :active OR PORTION_CONTROL.product_status = :toInactive OR  PORTION_CONTROL.date_desactivation >= :endOfWeek ) ';
        $sql .= ' AND    (PORTION_CONTROL.product_id >0) ';
        $sql .= ' ORDER BY PORTION_CONTROL.category_order, PORTION_CONTROL.description ';

        // bind
        $stm = $conn->prepare($sql);
        $active = ProductPurchased::ACTIVE;
        $toInactive = ProductPurchased::TO_INACTIVE;
        $stm->bindParam('startOfWeek', $startOfWeek);
        $stm->bindParam('endOfWeek', $endOfWeek);
        $stm->bindParam("origin_restaurant_id", $restaurantId);
        $stm->bindParam('locale', $locale);
        $stm->bindParam('active', $active);
        $stm->bindParam('toInactive', $toInactive);

        $stm->execute();
//        $temps_debut = microtime(true);
//        $stm->execute();
//        // Enregistrer le temps de fin
//         $temps_fin = microtime(true);

        // Calculer la dure d'excution en secondes
//          $duree_execution = $temps_fin - $temps_debut;

        // Afficher la dure d'excution
//         dump("SQL : " . $duree_execution );
        $data = $stm->fetchAll();
        //        dump($data);die;
        $result = [ "data" => $data,];


        return $result;

    }


}
